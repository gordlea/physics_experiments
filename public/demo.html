<html>
   <head>
      <title>Box2dWeb Demo</title>
   </head>
   <body onload="init();">
      <canvas id="canvas" width="1000" height="600" style="background-color:#333333;" ></canvas>
   </body>
   <script type="text/javascript" src="/js/vendor/box2d.js"></script>
   <script type="text/javascript" src="/js/keyboard.js"></script>
   <script type="text/javascript">
      
      function init() {
         var   b2Vec2 = Box2D.Common.Math.b2Vec2
                 , b2Math = Box2D.Common.Math.b2Math
            ,  b2AABB = Box2D.Collision.b2AABB
         	,	b2BodyDef = Box2D.Dynamics.b2BodyDef
         	,	b2Body = Box2D.Dynamics.b2Body
         	,	b2FixtureDef = Box2D.Dynamics.b2FixtureDef
         	,	b2Fixture = Box2D.Dynamics.b2Fixture
         	,	b2World = Box2D.Dynamics.b2World
         	,	b2MassData = Box2D.Collision.Shapes.b2MassData
         	,	b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape
         	,	b2CircleShape = Box2D.Collision.Shapes.b2CircleShape
         	,	b2DebugDraw = Box2D.Dynamics.b2DebugDraw
            ,  b2MouseJointDef =  Box2D.Dynamics.Joints.b2MouseJointDef
            ;
         
         var world = new b2World(
               new b2Vec2(0, 0)    //gravity
            ,  true                 //allow sleep
         );
         
         var fixDef = new b2FixtureDef;
         fixDef.density = 1.0;
         fixDef.friction = 0.5;
         fixDef.restitution = 0.2;
         
         var bodyDef = new b2BodyDef;
         
         //create ground
         bodyDef.type = b2Body.b2_staticBody;
         fixDef.shape = new b2PolygonShape;
         fixDef.shape.SetAsBox(30, 2);
         bodyDef.position.Set(10, 600 / 30 + 1.8);
         world.CreateBody(bodyDef).CreateFixture(fixDef);
         bodyDef.position.Set(10, -1.8);
         world.CreateBody(bodyDef).CreateFixture(fixDef);
         fixDef.shape.SetAsBox(2, 14);
         bodyDef.position.Set(-1.8, 13);
         world.CreateBody(bodyDef).CreateFixture(fixDef);
         bodyDef.position.Set(35.1, 13);
         world.CreateBody(bodyDef).CreateFixture(fixDef);


         var vertices = [5];
          vertices[0] = new b2Vec2(0, -3);
          vertices[1] = new b2Vec2(0.5, -1);
          vertices[2] = new b2Vec2(0.5, 3);
          vertices[3] = new b2Vec2(-0.5, 3);
          vertices[4] = new b2Vec2(-0.5, -1);


          //create some objects
         bodyDef.type = b2Body.b2_dynamicBody;
//         for(var i = 0; i < 10; ++i) {
//            if(Math.random() > 0.5) {
          fixDef.shape = new b2PolygonShape;
          fixDef.shape.SetAsArray(vertices, 5);
//               fixDef.shape.SetAsBox(
//                     Math.random() + 0.1 //half width
//                  ,  Math.random() + 0.1 //half height
//               );

//            } else {
//               fixDef.shape = new b2CircleShape(
//                  Math.random() + 0.1 //radius
//               );
//            }
            bodyDef.position.x = 16;
            bodyDef.position.y = 16;
          bodyDef.angularDamping = 1;
            var body = world.CreateBody(bodyDef);
          body.SetAngle((45 * Math.PI / 180));
      var fixture = body.CreateFixture(fixDef);
          console.log("body.GetMass() = %s", body.GetMass());
//         }
         
         //setup debug draw
         var debugDraw = new b2DebugDraw();
			debugDraw.SetSprite(document.getElementById("canvas").getContext("2d"));
			debugDraw.SetDrawScale(30.0);
			debugDraw.SetFillAlpha(0.5);
			debugDraw.SetLineThickness(1.0);
			debugDraw.SetFlags(b2DebugDraw.e_shapeBit | b2DebugDraw.e_jointBit);
			world.SetDebugDraw(debugDraw);
         
         window.setInterval(update, 1000 / 60);
         
         //mouse
         
         var mouseX, mouseY, mousePVec, isMouseDown, selectedBody, mouseJoint;
         var canvasPosition = getElementPosition(document.getElementById("canvas"));
         
//         document.addEventListener("mousedown", function(e) {
//            isMouseDown = true;
//            handleMouseMove(e);
//            document.addEventListener("mousemove", handleMouseMove, true);
//         }, true);
//
//         document.addEventListener("mouseup", function() {
//            document.removeEventListener("mousemove", handleMouseMove, true);
//            isMouseDown = false;
//            mouseX = undefined;
//            mouseY = undefined;
//         }, true);
//
//         function handleMouseMove(e) {
//            mouseX = (e.clientX - canvasPosition.x) / 30;
//            mouseY = (e.clientY - canvasPosition.y) / 30;
//         };
         
//         function getBodyAtMouse() {
//            mousePVec = new b2Vec2(mouseX, mouseY);
//            var aabb = new b2AABB();
//            aabb.lowerBound.Set(mouseX - 0.001, mouseY - 0.001);
//            aabb.upperBound.Set(mouseX + 0.001, mouseY + 0.001);
//
//            // Query the world for overlapping shapes.
//
//            selectedBody = null;
//            world.QueryAABB(getBodyCB, aabb);
//            return selectedBody;
//         }

         function getBodyCB(fixture) {
            if(fixture.GetBody().GetType() != b2Body.b2_staticBody) {
               if(fixture.GetShape().TestPoint(fixture.GetBody().GetTransform(), mousePVec)) {
                  selectedBody = fixture.GetBody();
                  return false;
               }
            }
            return true;
         }
         
         //update
         
         function update() {
         
//            if(isMouseDown && (!mouseJoint)) {
//               var body = getBodyAtMouse();
//               if(body) {
//                  var md = new b2MouseJointDef();
//                  md.bodyA = world.GetGroundBody();
//                  md.bodyB = body;
//                  md.target.Set(mouseX, mouseY);
//                  md.collideConnected = true;
//                  md.maxForce = 300.0 * body.GetMass();
//                  mouseJoint = world.CreateJoint(md);
//                  body.SetAwake(true);
//               }
//            }
            
//            if(mouseJoint) {
//               if(isMouseDown) {
//                  mouseJoint.SetTarget(new b2Vec2(mouseX, mouseY));
//               } else {
//                  world.DestroyJoint(mouseJoint);
//                  mouseJoint = null;
//               }
//            }


             var activeKeys = KeyboardJS.activeKeys();
             var ca = body.GetAngle() - (90 * Math.PI / 180);
             if (ca < 0) {
                 ca  += 2*Math.PI;
             }

             var localEngineLocation = new b2Vec2(0, 3);
             var localCenter = body.GetLocalCenter();

             var forwardForce = null;
             var torque = 0;

             for (var i = activeKeys.length - 1; i >= 0; i--) {
                 var key = activeKeys[i];
//                 console.log("key: %s", key);
                 switch(key) {
                     case "up":

//                             console.log("angleVector: %s", JSON.stringify(angleVector));
                        var forceVector = localCenter.Copy();
                        forceVector.Subtract(localEngineLocation);
                        forceVector.Normalize()
                         forceVector.Multiply(3);

                            forwardForce = {
                                forceVector: body.GetWorldVector(forceVector),
                                forcePoint: body.GetWorldPoint(localEngineLocation)
                            };

//
                         break;
                     case "left":
                         torque = -2;
                         break;
                     case "right":
                            torque = 2;
//                         body.ApplyTorque(2);
//                         var forceVectorLeft = localCenter.Copy();

//                         forceVectorLeft.Normalize();
//                         forceVectorLeft.Subtract(new b2Vec2(1,0));
//                         body.ApplyForce(body.GetWorldVector(forceVectorLeft),body.GetWorldPoint(localEngineLocation));
//                             var turnLeftForce = new b2Vec2(1, 3);
//
//                             turnLeftForce.Normalize();
//
//                             var engine = body.GetWorldPoint(localEngineLocation);
//                             console.log(lp);
//                        body.ApplyForce(body.GetWorldPoint(turnLeftForce), engine);
                 }
             }


             if (forwardForce !== null) {
                 body.ApplyForce(forwardForce.forceVector, forwardForce.forcePoint);
             }

             if (torque !== 0) {
                var velocity = body.GetLinearVelocity().Length();
//                 console.log("velocity: %d", velocity);
                 torque *= velocity;
                 body.ApplyTorque(torque);
             }


             killOrthogonalVelocity(body);

         
            world.Step(1 / 60, 10, 10);
            world.DrawDebugData();
            world.ClearForces();
         };
         
         //helpers

          function killOrthogonalVelocity( targetBody)
          {

              var localPoint = new b2Vec2(0,0);
              var velocity = targetBody.GetLinearVelocityFromLocalPoint(localPoint);
              var sidewaysAxis = targetBody.GetTransform().R.col2.Copy();
              sidewaysAxis.Multiply(b2Math.Dot(velocity,sidewaysAxis));
//              velocity.Set(0, velocity.y);
              targetBody.SetLinearVelocity(sidewaysAxis);
//              var forwardVelocity = car.Forward * Vector2.Dot(car.Velocity, car.Forward);
//              Vector2 rightVelocity = car.Right * Vector2.Dot(car.Velocity, car.Right);
//              car.Velocity = forwardVelocity + rightVelocity * drift;
          }
         
         //http://js-tut.aardon.de/js-tut/tutorial/position.html
         function getElementPosition(element) {
            var elem=element, tagname="", x=0, y=0;
           
            while((typeof(elem) == "object") && (typeof(elem.tagName) != "undefined")) {
               y += elem.offsetTop;
               x += elem.offsetLeft;
               tagname = elem.tagName.toUpperCase();

               if(tagname == "BODY")
                  elem=0;

               if(typeof(elem) == "object") {
                  if(typeof(elem.offsetParent) == "object")
                     elem = elem.offsetParent;
               }
            }

            return {x: x, y: y};
         }

//          KeyboardJS.bind.axis("up", "down", "left", "right", function(axis) {
//              var x = axis[0];
//              var y = axis[y];
//
//              console.log(axis);
//
//          });
      };


   
   </script>
   
   
</html>